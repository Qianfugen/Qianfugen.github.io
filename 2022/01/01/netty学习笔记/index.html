<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Netty学习笔记Chapter1-异步和事件驱动1.什么是Netty?Java网络编程提供的原生API复杂难用，而Netty将这些复杂难用的API接口优化封装，提供给我们简单易用的API接口。一句话，用较简单的抽象隐藏底层实现的复杂性。 Java原生API示例  是阻塞的，一个连接创建一个线程，效率低，最主要的是线程多了，上下文切换的开销很大  Netty使用了Java NIO，避免了以上问题">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty笔记">
<meta property="og:url" content="http://example.com/2022/01/01/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="qianfg的博客">
<meta property="og:description" content="Netty学习笔记Chapter1-异步和事件驱动1.什么是Netty?Java网络编程提供的原生API复杂难用，而Netty将这些复杂难用的API接口优化封装，提供给我们简单易用的API接口。一句话，用较简单的抽象隐藏底层实现的复杂性。 Java原生API示例  是阻塞的，一个连接创建一个线程，效率低，最主要的是线程多了，上下文切换的开销很大  Netty使用了Java NIO，避免了以上问题">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201028233349787.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201028233502910.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201028233638169.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201028232710848.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201104003246013.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201108235943161.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201109002159692.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201109005048076.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201109005829286.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201109010157044.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110224333245.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110224243277.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110225221714.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110232926060.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110234209901.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110235156473.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110235809946.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110235856288.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201111002226346.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201201232811821.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201201234151148.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201201234932610.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201201235053015.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201201235427423.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201201235924039.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202000624487.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202000916383.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202000927680.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202001703544.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202002656706.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202002943685.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202003513031.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202003702455.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202003814551.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202003839878.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202004333182.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202004731378.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202004850235.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202005412596.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201203234056579.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201203235842546.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201204004332540.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205191812446.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205195916893.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205202618498.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205202826258.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205204230623.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205211537126.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205214844754.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205215008778.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205215228539.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205215928052.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205215842844.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205221959288.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205230338069.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205230101135.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220104203014131.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220104203739603.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220104205902131.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220104211050089.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220110202427957.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220110203343888.png">
<meta property="og:image" content="http://example.com/2022/01/01/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img/image-20220110203103764.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220110203115724.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220110203638620.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220110203746456.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220111235435043.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220111235804630.png">
<meta property="article:published_time" content="2021-12-31T16:00:00.000Z">
<meta property="article:modified_time" content="2022-07-25T12:56:59.707Z">
<meta property="article:author" content="qianfg">
<meta property="article:tag" content="netty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201028233349787.png">


<link rel="canonical" href="http://example.com/2022/01/01/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2022/01/01/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","path":"2022/01/01/netty学习笔记/","title":"Netty笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Netty笔记 | qianfg的博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">qianfg的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="nav-text">Netty学习笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter1-%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="nav-text">Chapter1-异步和事件驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFNetty"><span class="nav-text">1.什么是Netty?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Netty%E4%BC%98%E7%82%B9"><span class="nav-text">2.Netty优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="nav-text">3.异步和事件驱动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-text">4.Netty核心组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter2-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%BENetty%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">Chapter2-你的第一款Netty应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Netty%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="nav-text">1.Netty客户端和服务端示意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BC%96%E5%86%99Echo%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">2.编写Echo服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-ChannelHandler%E5%92%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91"><span class="nav-text">2.1 ChannelHandler和业务逻辑</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-%E5%BC%95%E5%AF%BC%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">2.2 引导服务器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%BC%96%E5%86%99Echo%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">3. 编写Echo客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-ChannelHandler%E5%92%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91"><span class="nav-text">3.1 ChannelHandler和业务逻辑</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-%E5%BC%95%E5%AF%BC%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">3.2 引导客户端</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter3-Netty%E7%9A%84%E7%BB%84%E4%BB%B6%E5%92%8C%E8%AE%BE%E8%AE%A1"><span class="nav-text">Chapter3-Netty的组件和设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Channel%E6%8E%A5%E5%8F%A3"><span class="nav-text">1. Channel接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-EventLoop"><span class="nav-text">2. EventLoop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-ChannelFuture%E6%8E%A5%E5%8F%A3"><span class="nav-text">3. ChannelFuture接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-ChannelHandler%E6%8E%A5%E5%8F%A3"><span class="nav-text">4. ChannelHandler接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-ChannelPipeline%E6%8E%A5%E5%8F%A3"><span class="nav-text">5. ChannelPipeline接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%BC%95%E5%AF%BC"><span class="nav-text">6. 引导</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter4-%E4%BC%A0%E8%BE%93"><span class="nav-text">Chapter4-传输</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BC%A0%E8%BE%93%E8%BF%81%E7%A7%BB"><span class="nav-text">1. 传输迁移</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-%E6%9C%AA%E4%BD%BF%E7%94%A8netty%E7%9A%84OIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">1.1 未使用netty的OIO网络编程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-%E6%9C%AA%E4%BD%BF%E7%94%A8netty%E7%9A%84NIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">1.2 未使用netty的NIO网络编程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-%E4%BD%BF%E7%94%A8netty%E7%9A%84OIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">1.3 使用netty的OIO网络编程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-%E4%BD%BF%E7%94%A8netty%E7%9A%84NIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">1.4 使用netty的NIO网络编程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BC%A0%E8%BE%93API"><span class="nav-text">2. 传输API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%86%85%E7%BD%AE%E7%9A%84%E4%BC%A0%E8%BE%93"><span class="nav-text">3. 内置的传输</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-NIO-%E9%9D%9E%E9%98%BB%E5%A1%9EI-O"><span class="nav-text">3.1 NIO-非阻塞I&#x2F;O</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-Epoll-%E2%80%94-%E7%94%A8%E4%BA%8E-Linux-%E7%9A%84%E6%9C%AC%E5%9C%B0%E9%9D%9E%E9%98%BB%E5%A1%9E%E4%BC%A0%E8%BE%93"><span class="nav-text">3.2 Epoll — 用于 Linux 的本地非阻塞传输</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-OIO-%E2%80%94-%E6%97%A7%E7%9A%84%E9%98%BB%E5%A1%9E-I-O"><span class="nav-text">3.3 OIO — 旧的阻塞 I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%BC%A0%E8%BE%93%E7%9A%84%E7%94%A8%E4%BE%8B"><span class="nav-text">4. 传输的用例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter5-ByteBuf"><span class="nav-text">Chapter5-ByteBuf</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-ByteBuf-API%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">1. ByteBuf API的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-ByteBuf%E7%B1%BB-Netty%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8"><span class="nav-text">2.ByteBuf类-Netty的数据容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AD%97%E8%8A%82%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="nav-text">3.字节级操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-ByteBufHolder-%E6%8E%A5%E5%8F%A3"><span class="nav-text">4.ByteBufHolder 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-ByteBuf-%E5%88%86%E9%85%8D"><span class="nav-text">5.ByteBuf 分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-text">6.引用计数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter6-ChannelHandler-amp-ChannelPipeline"><span class="nav-text">Chapter6-ChannelHandler&amp;ChannelPipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-ChannelHandler%E6%8E%A5%E5%8F%A3"><span class="nav-text">1. ChannelHandler接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-Channel%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">1.1. Channel的生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-ChannelHandler%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">1.2. ChannelHandler的生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-ChannelInboundHandler%E6%8E%A5%E5%8F%A3"><span class="nav-text">1.3.ChannelInboundHandler接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-ChannelOutboundHandler%E6%8E%A5%E5%8F%A3"><span class="nav-text">1.4. ChannelOutboundHandler接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-ChannelHandler%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-text">1.5 ChannelHandler适配器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-ChannelPipeline%E6%8E%A5%E5%8F%A3"><span class="nav-text">2. ChannelPipeline接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-%E4%BF%AE%E6%94%B9ChannelPipeline"><span class="nav-text">2.1 修改ChannelPipeline</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6"><span class="nav-text">2.2 触发事件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-text"></span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-ChannelHandlerContext%E6%8E%A5%E5%8F%A3"><span class="nav-text">3. ChannelHandlerContext接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-%E4%BD%BF%E7%94%A8ChannelHandlerContext"><span class="nav-text">3.1 使用ChannelHandlerContext</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">4. 异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%A4%84%E7%90%86%E5%85%A5%E7%AB%99%E5%BC%82%E5%B8%B8"><span class="nav-text">1. 处理入站异常</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%A4%84%E7%90%86%E5%87%BA%E7%AB%99%E5%BC%82%E5%B8%B8"><span class="nav-text">2. 处理出站异常</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter7-EventLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">Chapter7-EventLoop和线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Executor%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">1.Executor线程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-EventLoop%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.EventLoop接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-FIFO"><span class="nav-text">3.FIFO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="nav-text">4.任务调度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1JDK%E7%9A%84API"><span class="nav-text">4.1JDK的API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2EventLoop"><span class="nav-text">4.2EventLoop</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-text">5.实现细节</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-text">5.1线程管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2EventLoop%E7%BA%BF%E7%A8%8B%E5%88%86%E9%85%8D"><span class="nav-text">5.2EventLoop线程分配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter8-%E5%BC%95%E5%AF%BC"><span class="nav-text">Chapter8-引导</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1Bootstrap-%E5%BC%95%E5%AF%BC%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">8.1Bootstrap-引导客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2ServerBootstrap-%E5%BC%95%E5%AF%BC%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">8.2ServerBootstrap-引导服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3ChannelOption-amp-Attr"><span class="nav-text">8.3ChannelOption&amp;Attr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4%E5%BC%95%E5%AF%BCDatagramChannel"><span class="nav-text">8.4引导DatagramChannel</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter9-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-text">Chapter9-单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1EmbeddedChannel"><span class="nav-text">9.1EmbeddedChannel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2%E6%B5%8B%E8%AF%95%E5%85%A5%E7%AB%99%E6%B6%88%E6%81%AF"><span class="nav-text">9.2测试入站消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3%E6%B5%8B%E8%AF%95%E5%87%BA%E7%AB%99%E6%B6%88%E6%81%AF"><span class="nav-text">9.3测试出站消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4%E6%B5%8B%E8%AF%95%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">9.4测试异常处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter10-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-text">Chapter10-编解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="nav-text">1.概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-text">2.解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1ByteToMessageDecoder"><span class="nav-text">2.1ByteToMessageDecoder</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2ReplayingDecoder"><span class="nav-text">2.2ReplayingDecoder</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3MessageToMessageDecoder"><span class="nav-text">2.3MessageToMessageDecoder</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4%E5%85%B6%E4%BB%96"><span class="nav-text">2.4其他</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-text">3.编码器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1MessageToByteEncoder"><span class="nav-text">3.1MessageToByteEncoder</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2MessageToMessageEncoder"><span class="nav-text">3.2MessageToMessageEncoder</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3%E5%85%B6%E4%BB%96"><span class="nav-text">3.3其他</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-text">4.编解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1%E6%8A%BD%E8%B1%A1%E7%B1%BB-ByteToMessageCodec"><span class="nav-text">4.1抽象类 ByteToMessageCodec</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2%E6%8A%BD%E8%B1%A1%E7%B1%BB-MessageToMessageCodec"><span class="nav-text">4.2抽象类 MessageToMessageCodec</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3CombinedChannelDuplexHandler-%E7%B1%BB"><span class="nav-text">4.3CombinedChannelDuplexHandler 类</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="qianfg"
      src="https://avatars.githubusercontent.com/u/35555226?v=4">
  <p class="site-author-name" itemprop="name">qianfg</p>
  <div class="site-description" itemprop="description">qianfg的个人博客，主要是Java学习笔记</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/01/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/35555226?v=4">
      <meta itemprop="name" content="qianfg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qianfg的博客">
      <meta itemprop="description" content="qianfg的个人博客，主要是Java学习笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Netty笔记 | qianfg的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Netty笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-01T00:00:00+08:00">2022-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-25 20:56:59" itemprop="dateModified" datetime="2022-07-25T20:56:59+08:00">2022-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Netty学习笔记"><a href="#Netty学习笔记" class="headerlink" title="Netty学习笔记"></a>Netty学习笔记</h1><h3 id="Chapter1-异步和事件驱动"><a href="#Chapter1-异步和事件驱动" class="headerlink" title="Chapter1-异步和事件驱动"></a>Chapter1-异步和事件驱动</h3><h4 id="1-什么是Netty"><a href="#1-什么是Netty" class="headerlink" title="1.什么是Netty?"></a>1.什么是Netty?</h4><p>Java网络编程提供的原生API复杂难用，而Netty将这些复杂难用的API接口优化封装，提供给我们简单易用的API接口。一句话，用较简单的抽象隐藏底层实现的复杂性。</p>
<p>Java原生API示例</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201028233349787.png" alt="image-20201028233349787"></p>
<p>是阻塞的，一个连接创建一个线程，效率低，最主要的是线程多了，上下文切换的开销很大</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201028233502910.png" alt="image-20201028233502910"></p>
<p>Netty使用了Java NIO，避免了以上问题</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201028233638169.png" alt="image-20201028233638169"></p>
<p>使用较少的线程便可以处理许多连接，因此也减少了内存管理和上下文切换所带来开销；</p>
<p>当没有 I/O 操作需要处理的时候，线程也可以被用于其他任务。</p>
<h4 id="2-Netty优点"><a href="#2-Netty优点" class="headerlink" title="2.Netty优点"></a>2.Netty优点</h4><ul>
<li>统一的 API，支持多种传输类型，阻塞的和非阻塞的</li>
<li>易于使用</li>
<li>拥有比 Java 的核心 API 更高的吞吐量以及更低的延迟</li>
<li>完整的 SSL/TLS 以及 StartTLS 支持</li>
<li>…</li>
</ul>
<h4 id="3-异步和事件驱动"><a href="#3-异步和事件驱动" class="headerlink" title="3.异步和事件驱动"></a>3.异步和事件驱动</h4><p>异步：for example，你在煮饭的同时，可以做菜，并发进行</p>
<p>事件驱动：for example，点击登录，进入网页，是由点击事件触发</p>
<h4 id="4-Netty核心组件"><a href="#4-Netty核心组件" class="headerlink" title="4.Netty核心组件"></a>4.Netty核心组件</h4><ul>
<li>Channel：可以看作是传入（入站）或者传出（出站）数据的载体</li>
<li>回调：其实就是一个方法，一个指向已经被提供给另外一个方法的方法的引用。这使得后<br>者可以在适当的时候调用前者。</li>
<li>Future：可以看作是一个异步操作的结果的占位符；它将在未来的某个时刻完成，并提供对其结果的访问。</li>
<li>事件：Netty使用不同的事件来通知我们状态的改变或者是操作的状态，让我们在已经的事件触发适当的动作。比如数据读取的时候，打印一个“hello world”</li>
<li>ChannelHandler：处理器，针对特定的事件执行特定的动作</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201028232710848.png" alt="image-20201028232710848"></p>
<p>事件被分发给ChannelHandler类中的方法，Netty处理链可以对事件进行过滤筛选，执行相应的动作。</p>
<h3 id="Chapter2-你的第一款Netty应用程序"><a href="#Chapter2-你的第一款Netty应用程序" class="headerlink" title="Chapter2-你的第一款Netty应用程序"></a>Chapter2-你的第一款Netty应用程序</h3><h4 id="1-Netty客户端和服务端示意图"><a href="#1-Netty客户端和服务端示意图" class="headerlink" title="1.Netty客户端和服务端示意图"></a>1.Netty客户端和服务端示意图</h4><p>实现功能：客户端发啥消息，服务端返回同样的消息，体现<strong>请求-响应交互模式</strong></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201104003246013.png" alt="image-20201104003246013"></p>
<h4 id="2-编写Echo服务器"><a href="#2-编写Echo服务器" class="headerlink" title="2.编写Echo服务器"></a>2.编写Echo服务器</h4><ul>
<li><p>ChannelHandler: 处理客户端发送数的据，及业务逻辑</p>
</li>
<li><p>引导：配置服务器的启动代码</p>
<p>很好体现了<strong>解耦</strong>思想，将业务逻辑与网络处理代码分离，分成两部分</p>
</li>
</ul>
<h5 id="2-1-ChannelHandler和业务逻辑"><a href="#2-1-ChannelHandler和业务逻辑" class="headerlink" title="2.1 ChannelHandler和业务逻辑"></a>2.1 ChannelHandler和业务逻辑</h5><ul>
<li>channelRead() : 对于每个传入的消息都要调用</li>
<li>channelReadComplete() : 通知ChannelInboundHandler最后一次对channelRead()的调用是当前批量读取中的最后一条消息</li>
<li>exceptionCaught() :  在读取操作期间，有异常抛出时会调用</li>
</ul>
<p><strong>EchoServerHandler</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;Server reveived: &quot;</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">        ctx.write(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChannelInboundHandlerAdapter 有一个直观的 API，并且<strong>它的每个方法都可以被重写以挂钩到事件生命周期的恰当点上</strong></p>
<h5 id="2-2-引导服务器"><a href="#2-2-引导服务器" class="headerlink" title="2.2 引导服务器"></a>2.2 引导服务器</h5><ul>
<li>绑定监听端口，并接受传入的连接请求</li>
<li>配置 Channel ，以将有关的入站消息通知给 EchoServerHandler 实例</li>
</ul>
<p><strong>EchoServer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">                            channel.pipeline().addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind().sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Echo Server start...&quot;</span>);</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully().sync();</span><br><span class="line">            workGroup.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建一个<code>ServerBootstrap</code>的实例以引导和绑定服务器</p>
</li>
<li><p>创建并分配一个<code>NioEventLoopGroup</code>实例以进行事件的处理，如接受新连接或读写数据</p>
</li>
<li><p>指定服务器绑定的本地的 <code>InetSocketAddress</code></p>
</li>
<li><p>使用一个 <code>EchoServerHandler </code>的实例初始化每一个新的 Channel</p>
</li>
<li><p>调用 <code>ServerBootstrap.bind()</code>方法以绑定服务器</p>
</li>
</ul>
<h4 id="3-编写Echo客户端"><a href="#3-编写Echo客户端" class="headerlink" title="3. 编写Echo客户端"></a>3. 编写Echo客户端</h4><h5 id="3-1-ChannelHandler和业务逻辑"><a href="#3-1-ChannelHandler和业务逻辑" class="headerlink" title="3.1 ChannelHandler和业务逻辑"></a>3.1 ChannelHandler和业务逻辑</h5><ul>
<li>channelActive(): 在与服务器的连接建立之后被调用</li>
<li>channelRead0(): 当从服务器接收到一条消息时被调用</li>
<li>exceptionCaught(): 在处理过程中引发异常时被调用</li>
</ul>
<p><strong>EchoClientHandler</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Client received:&quot;</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;Netty rocks!&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-引导客户端"><a href="#3-2-引导客户端" class="headerlink" title="3.2 引导客户端"></a>3.2 引导客户端</h5><p><strong>EchoClient</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            channel.pipeline().addLast(<span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .remoteAddress(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1234</span>));</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect().sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Echo Client Start...&quot;</span>);</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为初始化客户端，创建了一个<code>Bootstrap</code>实例</li>
<li>为进行事件处理分配了一个<code>NioEventLoopGroup</code>实例，其中事件处理包括<strong>创建新的连接以及处理入站和出站数据</strong></li>
<li>为服务器连接创建了一个 <code>InetSocketAddress </code>实例</li>
<li>当连接被建立时，一个 <code>EchoClientHandler</code> 实例会被安装到（该 Channel 的）<code>ChannelPipeline</code> 中</li>
<li>在一切都设置完成后，调用 <code>Bootstrap.connect()</code>方法连接到远程节点</li>
</ul>
<h3 id="Chapter3-Netty的组件和设计"><a href="#Chapter3-Netty的组件和设计" class="headerlink" title="Chapter3-Netty的组件和设计"></a>Chapter3-Netty的组件和设计</h3><h4 id="1-Channel接口"><a href="#1-Channel接口" class="headerlink" title="1. Channel接口"></a>1. Channel接口</h4><p>基本的 I/O 操作（bind()、connect()、read()和 write()）依赖于底层网络传输所提供的原语。</p>
<p>eg:</p>
<ul>
<li>EmbeddedChannel</li>
<li>LocalServerChannel</li>
<li>NioDatagramChannel</li>
<li>NioSctcpChannel</li>
<li>NioSocketChannel</li>
</ul>
<h4 id="2-EventLoop"><a href="#2-EventLoop" class="headerlink" title="2. EventLoop"></a>2. EventLoop</h4><p>EventLoop定义了Netty的核心抽象，用于处理连接的生命周期所发生的事件。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201108235943161.png" alt="image-20201108235943161"></p>
<ul>
<li>一个<code>EventLoopGroup</code>包括一个或多个<code>EventLoop</code></li>
<li>一个<code>EventLoop</code>在它的生命周期内只和一个<code>Thread</code>绑定</li>
<li>所有由<code>EventLoop</code>处理的I/O事件都将在它专有的Thread上处理</li>
<li>一个<code>Channel</code>在它的生命周期内只注册于一个<code>EventLoop</code></li>
<li>一个EventLoop可能会被分配给一个或多个<code>Channel</code></li>
</ul>
<h4 id="3-ChannelFuture接口"><a href="#3-ChannelFuture接口" class="headerlink" title="3. ChannelFuture接口"></a>3. ChannelFuture接口</h4><p>Netty 中所有的 I/O 操作都是异步的。因为一个操作可能不会立即返回，所以我们需要一种用于在之后的某个时间点确定其结果的方法。为此，Netty 提供了ChannelFuture 接口，其 addListener()方法注册了一个 ChannelFutureListener，以便在某个操作完成时（无论是否成功）得到通知。</p>
<h4 id="4-ChannelHandler接口"><a href="#4-ChannelHandler接口" class="headerlink" title="4. ChannelHandler接口"></a>4. ChannelHandler接口</h4><p>ChannelHandler充当了所有处理入站和出站数据的应用程序逻辑的容器。</p>
<p>例如将数据从一种格式转换为另外一种格式，或者处理转换过程中所抛出的异常。</p>
<h4 id="5-ChannelPipeline接口"><a href="#5-ChannelPipeline接口" class="headerlink" title="5. ChannelPipeline接口"></a>5. ChannelPipeline接口</h4><p>ChannelPipeline 提供了 ChannelHandler 链的容器，并定义了用于在该链上传播入站和出站事件流的 API。当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。</p>
<p>ChannelHandler安装到ChannelPipeline中的过程如下：</p>
<ul>
<li>一个<code>ChannelInitializer</code>的实现被注册到了<code>ServerBootstrap</code>中</li>
<li>当 <code>ChannelInitializer.initChannel()</code>方法被调用时，ChannelInitializer将在 ChannelPipeline 中安装一组自定义的 ChannelHandler</li>
<li><code>ChannelInitializer</code> 将它自己从 <code>ChannelPipeline</code> 中移除</li>
</ul>
<p>Netty应用程序入站和出站数据流</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201109002159692.png" alt="image-20201109002159692"></p>
<p><strong>入站</strong>：一个入站消息被读取，那么它会从 ChannelPipeline 的头部开始流动，并被传递给第一个 ChannelInboundHandler。这个 ChannelHandler 不一定会实际地修改数据，具体取决于它的具体功能，在这之后，数据将会被传递给链中的下一个ChannelInboundHandler。最终，数据将会到达 ChannelPipeline 的尾端，届时，所有处理就都结束了。</p>
<p><strong>出站</strong>：数据将从ChannelOutboundHandler 链的尾端开始流动，直到它到达链的头部为止。在这之后，出站数据将会到达网络传输层，这里显示为 Socket。通常情况下，这将触发一个写操作。</p>
<p>在Netty中，有两种发送消息的方式。</p>
<ol>
<li>你可以直接写到<code>Channel</code>中，将会导致消息从Channel-Pipeline 的尾端开始流动</li>
<li>也可以 写到和Channel-Handler相关联的<code>ChannelHandlerContext</code>对象中，导致消息从 ChannelPipeline 中的下一个 Channel-Handler 开始流动</li>
</ol>
<p>常用的适配器类</p>
<ul>
<li><code>ChannelHandlerAdapter</code>: 处理入站和出站消息</li>
<li><code>ChannelInboundHandlerAdapter</code>: 处理入站消息</li>
<li><code>ChannelOutboundHandlerAdapter</code>: 处理出站消息</li>
<li><code>ChannelDuplexHandler</code>: 收发消息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201109005048076.png" alt="image-20201109005048076"></p>
<p>解码器：将netty接收的字节数组转成另一种格式，通常是一个Java对象</p>
<p>编码器：跟解码器相反，将一个对象转成字节数组</p>
<h4 id="6-引导"><a href="#6-引导" class="headerlink" title="6. 引导"></a>6. 引导</h4><p>Netty 的引导类为应用程序的网络层配置提供了容器，这涉及将一个进程绑定到某个指定的端口（服务器引导）</p>
<p>或者将一个进程连接到另一个运行在某个指定主机的指定端口上的进程（客户端引导）。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201109005829286.png" alt="image-20201109005829286"></p>
<p>因为服务器需要两组不同的 Channel。第一组将只包含一个 ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字。而第二组将包含所有已创建的用来处理传入客户端连接（对于每个服务器已经接受的连接都有一个）的 Channel。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201109010157044.png" alt="image-20201109010157044"></p>
<p>与 ServerChannel 相关联的 EventLoopGroup 将分配一个负责为传入连接请求创建Channel 的 EventLoop。一旦连接被接受，第二个 EventLoopGroup 就会给它的 Channel分配一个 EventLoop。</p>
<h3 id="Chapter4-传输"><a href="#Chapter4-传输" class="headerlink" title="Chapter4-传输"></a>Chapter4-传输</h3><h4 id="1-传输迁移"><a href="#1-传输迁移" class="headerlink" title="1. 传输迁移"></a>1. 传输迁移</h4><h5 id="1-1-未使用netty的OIO网络编程"><a href="#1-1-未使用netty的OIO网络编程" class="headerlink" title="1.1 未使用netty的OIO网络编程"></a>1.1 未使用netty的OIO网络编程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainOioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">1234</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Socket clientSocket = serverSocket.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;Accepted connection from &quot;</span> + clientSocket);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 读取客户端发来的消息</span></span><br><span class="line">                            BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">                            String reveiveMsg = in.readLine();</span><br><span class="line">                            System.out.println(<span class="string">&quot;客户端发来的消息是：&quot;</span> + reveiveMsg);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 回传消息给客户端</span></span><br><span class="line">                            out = clientSocket.getOutputStream();</span><br><span class="line">                            out.write(<span class="string">&quot;hello&quot;</span>.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">                            out.flush();</span><br><span class="line">                            clientSocket.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                clientSocket.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-未使用netty的NIO网络编程"><a href="#1-2-未使用netty的NIO网络编程" class="headerlink" title="1.2 未使用netty的NIO网络编程"></a>1.2 未使用netty的NIO网络编程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainNioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ServerSocket serverSocket = serverChannel.socket();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        ByteBuffer msg = ByteBuffer.wrap(<span class="string">&quot;hello&quot;</span>.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">                        SocketChannel client = server.accept();</span><br><span class="line">                        client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, msg.duplicate());</span><br><span class="line">                        System.out.println(<span class="string">&quot;Accepted connection from &quot;</span> + client);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">                        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (client.write(buffer) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    key.cancel();</span><br><span class="line">                    key.channel().close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-使用netty的OIO网络编程"><a href="#1-3-使用netty的OIO网络编程" class="headerlink" title="1.3 使用netty的OIO网络编程"></a>1.3 使用netty的OIO网络编程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyOioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(<span class="string">&quot;hello&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> OioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(group)</span><br><span class="line">                    .channel(OioServerSocketChannel.class)</span><br><span class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture cf = b.bind().sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Server Start...&quot;</span>);</span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-4-使用netty的NIO网络编程"><a href="#1-4-使用netty的NIO网络编程" class="headerlink" title="1.4 使用netty的NIO网络编程"></a>1.4 使用netty的NIO网络编程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyNioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(<span class="string">&quot;hello&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">// 改动1</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(group)</span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">// 改动2</span></span><br><span class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture cf = b.bind().sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Server Start...&quot;</span>);</span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，java原生的OIO和NIO网络编程变化很大，复杂难用。但是netty的OIO和NIO网络编程，为每种传输的实现都暴露了相同的 API，所以无论选用哪一种传输的实现，你的代码都仍然几乎不受影响。</p>
<h4 id="2-传输API"><a href="#2-传输API" class="headerlink" title="2. 传输API"></a>2. 传输API</h4><p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110224333245.png" alt="image-20201110224333245"></p>
<p>每个 Channel 都将会被分配一个 <code>ChannelPipeline</code> 和 <code>ChannelConfig</code>。</p>
<p>ChannelConfig 包含了该 Channel 的所有配置设置，并且支持热更新。</p>
<p>ChannelPipeline 持有所有将应用于入站和出站数据以及事件的 ChannelHandler 实例，这些 ChannelHandler 实现了应用程序用于处理状态变化以及数据处理的逻辑。</p>
<p><strong>ChannelHandler的典型用途：</strong></p>
<ul>
<li>将数据从一种格式转成另一种格式</li>
<li>提供异常的通知</li>
<li>提供Channel变为活动或非活动的通知</li>
<li>提供当Channel注册到EventLoop或者从EventLoop注销时的通知</li>
<li>提供有关用户自定义事件的通知</li>
</ul>
<p><strong>拦截过滤器</strong>：ChannelPipeline 实现了一种常见的设计模式 — 拦截过滤器（Intercepting Filter）。UNIX 管道是另外一个熟悉的例子：多个命令被链接在一起，其中一个命令的输出端将连接到命令行中下一个命令的输入端。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110224243277.png" alt="image-20201110224243277"></p>
<h4 id="3-内置的传输"><a href="#3-内置的传输" class="headerlink" title="3. 内置的传输"></a>3. 内置的传输</h4><p>​                                                                <strong>Netty所提供的传输</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>包</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NIO</td>
<td>io.netty.channel.socket.nio</td>
<td>使用 java.nio.channels 包作为基础——基于<br/>选择器的方式</td>
</tr>
<tr>
<td>Epoll</td>
<td>io.netty.channel.epoll</td>
<td>由 JNI 驱动的 epoll() 和非阻塞 IO。这个传输支持<br/>只有在Linux上可用的多种特性，如 SO_REUSEPORT ，<br/>比NIO 传输更快，而且是完全非阻塞的</td>
</tr>
<tr>
<td>OIO</td>
<td>io.netty.channel.socket.oio</td>
<td>使用 java.net 包作为基础——使用阻塞流</td>
</tr>
<tr>
<td>Local</td>
<td>io.netty.channel.local</td>
<td>可以在 VM 内部通过管道进行通信的本地传输</td>
</tr>
<tr>
<td>Embedded</td>
<td>io.netty.channel.embedded</td>
<td>Embedded 传输，允许使用 ChannelHandler 而又<br/>不需要一个真正的基于网络的传输。这在测试你的<br/>ChannelHandler 实现时非常有用</td>
</tr>
</tbody></table>
<h5 id="3-1-NIO-非阻塞I-O"><a href="#3-1-NIO-非阻塞I-O" class="headerlink" title="3.1 NIO-非阻塞I/O"></a>3.1 NIO-非阻塞I/O</h5><p>NIO 提供了一个所有 I/O 操作的全异步的实现，选择器Selector充当一个注册表。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110225221714.png" alt="image-20201110225221714"></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110232926060.png" alt="image-20201110232926060"></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110234209901.png" alt="image-20201110234209901"></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110235156473.png" alt="image-20201110235156473"></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110235809946.png" alt="image-20201110235809946"></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201110235856288.png" alt="image-20201110235856288"></p>
<ol>
<li>当客户端连接时，会通过<code>ServerSocketChannel</code>得到<code>SocketChannel</code></li>
<li>将SocketChannel注册到<code>Selector</code>上，<code>register(Selector sel, int ops)</code>，一个Selector可以注册多个SocketChannel</li>
<li>注册后返回一个SelectionKey，会和该Selector关联（集合）</li>
<li>Selector进行监听，<code>select()</code>，返回有事件发生的通道个数</li>
<li>进一步得到各个<code>SelectionKey</code>(有事件发生时)</li>
<li>在通过SelectionKey的<code>channel()</code>反向获取SocketChannel</li>
<li>可以通过得到的channel，完成业务处理</li>
</ol>
<h5 id="3-2-Epoll-—-用于-Linux-的本地非阻塞传输"><a href="#3-2-Epoll-—-用于-Linux-的本地非阻塞传输" class="headerlink" title="3.2 Epoll — 用于 Linux 的本地非阻塞传输"></a>3.2 Epoll — 用于 Linux 的本地非阻塞传输</h5><p><strong>高负载下性能更佳，优于JDK的NIO实现</strong></p>
<p>Linux作为高性能网络编程的平台，其重要性与日俱增，这催生了大量先进特性的开发，其中包括<strong>epoll——一个高度可扩展的I/O事件通知特性</strong>。这个API自Linux内核版本 2.5.44（2002）被引入，提供了比旧的POSIX select和poll系统调用更好的性能，同时现在也是Linux上非阻塞网络编程的事实标准。</p>
<h5 id="3-3-OIO-—-旧的阻塞-I-O"><a href="#3-3-OIO-—-旧的阻塞-I-O" class="headerlink" title="3.3 OIO — 旧的阻塞 I/O"></a>3.3 OIO — 旧的阻塞 I/O</h5><p>Netty 的 OIO 传输实现代表了一种折中：它可以通过常规的传输 API 使用，但是由于它是建立在 java.net 包的阻塞实现之上的，所以它不是异步的。</p>
<p>Netty是如何能够使用和用于异步传输相同的API来支持OIO的呢？<br>答案就是，Netty利用了SO_TIMEOUT这个Socket标志，它指定了等待一个I/O操作完成的最大毫秒数。如果操作在指定的时间间隔内没有完成，则将会抛出一个SocketTimeout Exception。Netty将捕获这个异常并继续处理循环。在EventLoop下一次运行时，它将再次尝试。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201111002226346.png" alt="image-20201111002226346"></p>
<h4 id="4-传输的用例"><a href="#4-传输的用例" class="headerlink" title="4. 传输的用例"></a>4. 传输的用例</h4><p>​                                                                                <strong>应用程序的最佳传输</strong></p>
<table>
<thead>
<tr>
<th>应用程序的需求</th>
<th>推荐的传输</th>
</tr>
</thead>
<tbody><tr>
<td>非阻塞代码库或者一个常规的起点</td>
<td>NIO(或者在Linux上使用Epoll)</td>
</tr>
<tr>
<td>阻塞代码库</td>
<td>OIO</td>
</tr>
<tr>
<td>在同一个JVM内部的通信</td>
<td>Local</td>
</tr>
<tr>
<td>测试ChannelHandler的实现</td>
<td>Embedded</td>
</tr>
</tbody></table>
<h3 id="Chapter5-ByteBuf"><a href="#Chapter5-ByteBuf" class="headerlink" title="Chapter5-ByteBuf"></a>Chapter5-ByteBuf</h3><h4 id="1-ByteBuf-API的优点"><a href="#1-ByteBuf-API的优点" class="headerlink" title="1. ByteBuf API的优点"></a>1. ByteBuf API的优点</h4><ul>
<li>自定义缓冲区类型扩展</li>
<li>零拷贝</li>
<li>容量按需增长</li>
<li>读写模式不需要调用ByteBuffer的flip()切换</li>
<li>读写索引分离</li>
<li>支持方法的链式调用</li>
<li>支持引用计数</li>
<li>支持池化</li>
<li>…</li>
</ul>
<h4 id="2-ByteBuf类-Netty的数据容器"><a href="#2-ByteBuf类-Netty的数据容器" class="headerlink" title="2.ByteBuf类-Netty的数据容器"></a>2.ByteBuf类-Netty的数据容器</h4><p><strong>工作模式</strong></p>
<p>ByteBuf 维护了两个不同的索引：一个用于读取，一个用于写入。当你从 ByteBuf 读取时，它的 readerIndex 将会被递增已经被读取的字节数。同样地，当你写入 ByteBuf 时，它的writerIndex 也会被递增。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201201232811821.png" alt="image-20201201232811821"></p>
<p><strong>使用模式</strong></p>
<ol>
<li><p>堆缓冲区</p>
<p>最常用的 ByteBuf 模式是将数据存储在 JVM 的堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放</p>
</li>
<li><p>直接缓冲区</p>
<p>直接缓冲区是另外一种 ByteBuf 模式。我们期望用于对象创建的内存分配永远都来自于堆中，但这并不是必须的——NIO 在 JDK 1.4 中引入的 ByteBuffer 类允许 JVM 实现通过本地调用来分配内存。</p>
</li>
<li><p>复合缓冲区</p>
<p>第三种也是最后一种模式使用的是复合缓冲区，它为多个 ByteBuf 提供一个聚合视图。在这里你可以根据需要添加或者删除 ByteBuf 实例，这是一个 JDK 的 ByteBuffer 实现完全缺失的特性。<br>Netty 通过一个 ByteBuf 子类——CompositeByteBuf ——实现了这个模式，它提供了一个将多个缓冲区表示为单个合并缓冲区的虚拟表示。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201201234151148.png" alt="image-20201201234151148"></p>
</li>
</ol>
<h4 id="3-字节级操作"><a href="#3-字节级操作" class="headerlink" title="3.字节级操作"></a>3.字节级操作</h4><ol>
<li><p>随机访问索引</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201201234932610.png" alt="image-20201201234932610"></p>
</li>
<li><p>顺序访问索引</p>
<p>虽然 ByteBuf 同时具有读索引和写索引，但是 JDK 的 ByteBuffer 却只有一个索引，这也就是为什么必须调用 flip()方法来在读模式和写模式之间进行切换的原因。图 5-3 展示了ByteBuf 是如何被它的两个索引划分成 3 个区域的。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201201235053015.png" alt="image-20201201235053015"></p>
</li>
<li><p>可丢弃字节</p>
<p>在图 5-3 中标记为可丢弃字节的分段包含了已经被读过的字节。通过调用 discardReadBytes()方法，可以丢弃它们并回收空间。这个分段的初始大小为 0，存储在 readerIndex 中，会随着 read 操作的执行而增加。</p>
<p>缓冲区上调用discardReadBytes()方法后的结果。可以看到，可丢弃字节分段中的空间已经变为可写的了</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201201235427423.png" alt="image-20201201235427423"></p>
</li>
<li><p>可读字节</p>
<p>ByteBuf 的可读字节分段存储了实际数据。新分配的、包装的或者复制的缓冲区的默认的readerIndex 值为 0。任何名称以 read 或者 skip 开头的操作都将检索或者跳过位于当前readerIndex 的数据，并且将它增加已读字节数。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201201235924039.png" alt="image-20201201235924039"></p>
</li>
<li><p>可写字节</p>
<p>可写字节分段是指一个拥有未定义内容的、写入就绪的内存区域。新分配的缓冲区的writerIndex 的默认值为 0。任何名称以 write 开头的操作都将从当前的 writerIndex 处开始写数据，并将它增加已经写入的字节数。如果写操作的目标也是 ByteBuf，并且没有指定源索引的值，则源缓冲区的 readerIndex 也同样会被增加相同的大小。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202000624487.png" alt="image-20201202000624487"></p>
</li>
<li><p>索引管理</p>
<p>可以通过调用markReaderIndex()、markWriterIndex()、resetWriterIndex()和 resetReaderIndex()来标记和重置 ByteBuf 的 readerIndex 和 writerIndex。</p>
<p>可以通过调用 clear()方法来将 readerIndex 和 writerIndex 都设置为 0。注意，这并不会清除内存中的内容。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202000916383.png" alt="image-20201202000916383"></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202000927680.png" alt="image-20201202000927680"></p>
</li>
<li><p>查找操作</p>
<p>在 ByteBuf中有多种可以用来确定指定值的索引的方法。最简单的是使用indexOf()方法。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202001703544.png" alt="image-20201202001703544"></p>
</li>
<li><p>派生缓冲区</p>
<p>派生缓冲区为 ByteBuf 提供了以专门的方式来呈现其内容的视图。这类视图是通过以下方法被创建的</p>
<ul>
<li>duplicate()</li>
<li>slice()</li>
<li>slice(int, int)</li>
<li>Unpooled.unmodifiableBuffer(…)</li>
<li>order(ByteOrder)</li>
<li>readSlice(int)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202002656706.png" alt="image-20201202002656706"></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202002943685.png" alt="image-20201202002943685"></p>
</li>
<li><p>读/写操作</p>
<p>正如我们所提到过的，有两种类别的读/写操作：</p>
<ul>
<li>get()和 set()操作，从给定的索引开始，并且保持索引不变；</li>
<li>read()和 write()操作，从给定的索引开始，并且会根据已经访问过的字节数对索引进行调整。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202003513031.png" alt="image-20201202003513031"></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202003702455.png" alt="image-20201202003702455"></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202003814551.png" alt="image-20201202003814551"></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202003839878.png" alt="image-20201202003839878"></p>
</li>
</ol>
<h4 id="4-ByteBufHolder-接口"><a href="#4-ByteBufHolder-接口" class="headerlink" title="4.ByteBufHolder 接口"></a>4.ByteBufHolder 接口</h4><p>我们经常发现，除了实际的数据负载之外，我们还需要存储各种属性值。HTTP 响应便是一个很好的例子，除了表示为字节的内容，还包括状态码、cookie 等。为了处理这种常见的用例，Netty 提供了 ByteBufHolder。ByteBufHolder 也为 Netty 的高级特性提供了支持，如缓冲区池化，其中可以从池中借用 ByteBuf，并且在需要时自动释放。</p>
<p>如果想要实现一个将其有效负载存储在 ByteBuf 中的消息对象，那么 ByteBufHolder 将是个不错的选择。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202004333182.png" alt="image-20201202004333182"></p>
<h4 id="5-ByteBuf-分配"><a href="#5-ByteBuf-分配" class="headerlink" title="5.ByteBuf 分配"></a>5.ByteBuf 分配</h4><ol>
<li><p>按需分配：ByteBufAllocator 接口</p>
<p>为了降低分配和释放内存的开销，Netty 通过 interface ByteBufAllocator 实现了（ByteBuf 的）池化，它可以用来分配我们所描述过的任意类型的 ByteBuf 实例。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202004731378.png" alt="image-20201202004731378"></p>
</li>
<li><p>Unpooled 缓冲区</p>
<p>Netty 提供了一个简单的称为 Unpooled 的工具类，它提供了静态的辅助方法来创建未池化的 ByteBuf实例。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202004850235.png" alt="image-20201202004850235"></p>
</li>
<li><p>ByteBufUtil 类</p>
<p>ByteBufUtil 提供了用于操作 ByteBuf 的静态的辅助方法。</p>
<p> <code>hexdump()</code>方法，它以十六进制的表示形式打印ByteBuf 的内容。这在各种情况下都很有用，例如，出于调试的目的记录 ByteBuf 的内容。十六进制的表示通常会提供一个比字节值的直接表示形式更加有用的日志条目，此外，十六进制的版本还可以很容易地转换回实际的字节表示。</p>
<p> <code>boolean equals(ByteBuf, ByteBuf)</code>，它被用来判断两个 ByteBuf实例的相等性。</p>
</li>
</ol>
<h4 id="6-引用计数"><a href="#6-引用计数" class="headerlink" title="6.引用计数"></a>6.引用计数</h4><p>引用计数是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。</p>
<p>引用计数背后的想法并不是特别的复杂；它主要涉及跟踪到某个特定对象的活动引用的数量。一个ReferenceCounted 实现的实例将通常以活动的引用计数为 1 作为开始。只要引用计数大于 0，就能保证对象不会被释放。当活动引用的数量减少到 0 时，该实例就会被释放。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201202005412596.png" alt="image-20201202005412596"></p>
<h3 id="Chapter6-ChannelHandler-amp-ChannelPipeline"><a href="#Chapter6-ChannelHandler-amp-ChannelPipeline" class="headerlink" title="Chapter6-ChannelHandler&amp;ChannelPipeline"></a>Chapter6-ChannelHandler&amp;ChannelPipeline</h3><h4 id="1-ChannelHandler接口"><a href="#1-ChannelHandler接口" class="headerlink" title="1. ChannelHandler接口"></a>1. ChannelHandler接口</h4><h5 id="1-1-Channel的生命周期"><a href="#1-1-Channel的生命周期" class="headerlink" title="1.1. Channel的生命周期"></a>1.1. Channel的生命周期</h5><table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ChannelUnregistered</td>
<td>Channel已被创建，但未被注册到EventLoop</td>
</tr>
<tr>
<td>ChannelRegistered</td>
<td>Channel已被注册到EventLoop</td>
</tr>
<tr>
<td>ChannelActive</td>
<td>Channel处于活动状态，可以接收和发送数据了</td>
</tr>
<tr>
<td>ChannelInactive</td>
<td>Channel没有连接到远程节点</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201203234056579.png" alt="image-20201203234056579"></p>
<h5 id="1-2-ChannelHandler的生命周期"><a href="#1-2-ChannelHandler的生命周期" class="headerlink" title="1.2. ChannelHandler的生命周期"></a>1.2. ChannelHandler的生命周期</h5><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>handlerAdded</td>
<td>当把ChannelHandler添加到ChannelPipeline中时被调用</td>
</tr>
<tr>
<td>handlerRemoved</td>
<td>当ChannelHandler被从ChannelPipeline中移除时调用</td>
</tr>
<tr>
<td>exceptionCaught</td>
<td>当处理过程中在ChannelPipeline中有错误产生时被调用</td>
</tr>
</tbody></table>
<h5 id="1-3-ChannelInboundHandler接口"><a href="#1-3-ChannelInboundHandler接口" class="headerlink" title="1.3.ChannelInboundHandler接口"></a>1.3.ChannelInboundHandler接口</h5><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>channelRegistered</td>
<td>当Channel注册到它的EventLoop并且能够处理I/O时被调用</td>
</tr>
<tr>
<td>channelUnregistered</td>
<td>当Channel从它的EventLoop注销并不能处理I/O时调用</td>
</tr>
<tr>
<td>channelActive</td>
<td>当Channel处于活动状态时被调用；Channel已经连接/绑定并且已经就绪</td>
</tr>
<tr>
<td>channelInactive</td>
<td>当Channel离开活动状态并且不再连接远程节点时被调用</td>
</tr>
<tr>
<td>channelRead</td>
<td>当从Channel中读取数据时被调用</td>
</tr>
<tr>
<td>channelReadComplete</td>
<td>当Channel上的一个读操作完成时被调用</td>
</tr>
<tr>
<td>userEventTriggered</td>
<td>当ChannelInboundHandler.fireUserEventTriggered()方法被调用时调用，因为一个POJO被传经了ChannelPipeline</td>
</tr>
<tr>
<td>channelWritabilityChanged</td>
<td>当 Channel 的可写状态发生改变时被调用。</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201203235842546.png" alt="image-20201203235842546"></p>
<p>ChannelInboundHandlerAdapter需要显示的释放资源，比如ReferenceCountUtil.release(msg)</p>
<p>SimpleChannelInboundHandler则不需要任何显示的资源释放，因为它帮你自动释放了</p>
<h5 id="1-4-ChannelOutboundHandler接口"><a href="#1-4-ChannelOutboundHandler接口" class="headerlink" title="1.4. ChannelOutboundHandler接口"></a>1.4. ChannelOutboundHandler接口</h5><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</td>
<td>当请求将Channel绑定到本地地址时被调用</td>
</tr>
<tr>
<td>connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,         SocketAddress localAddress, ChannelPromise promise)</td>
<td>当请求将Channel连接到远程节点时调用</td>
</tr>
<tr>
<td>disconnect(ChannelHandlerContext ctx, ChannelPromise promise)</td>
<td>当请求从远程节点断开时被调用</td>
</tr>
<tr>
<td>close(ChannelHandlerContext ctx, ChannelPromise promise)</td>
<td>当请求关闭Channel时被调用</td>
</tr>
<tr>
<td>deregister(ChannelHandlerContext ctx, ChannelPromise promise)</td>
<td>当请求从它的EventLoop注销时被调用</td>
</tr>
<tr>
<td>read(ChannelHandlerContext ctx)</td>
<td>当请求从Channel读取更多的数据时被调用</td>
</tr>
<tr>
<td>write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</td>
<td>当请求通过Channel将数据写到远程节点时被调用</td>
</tr>
<tr>
<td>flush(ChannelHandlerContext ctx)</td>
<td>当请求通过Channel将入队数据冲刷到远程节点时被调用</td>
</tr>
</tbody></table>
<p><strong>ChannelPromise</strong>: 是ChannelFuture的一个子类，其定义了一些可写的方法，入setSuccess()和setFailure()，从而使ChannelFuture不可变。</p>
<h5 id="1-5-ChannelHandler适配器"><a href="#1-5-ChannelHandler适配器" class="headerlink" title="1.5 ChannelHandler适配器"></a>1.5 ChannelHandler适配器</h5><p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201204004332540.png" alt="image-20201204004332540"></p>
<p>你可以使用 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter类作为自己的ChannelHandler 的起始点。这两个适配器分别提供了ChannelInboundHandler和 ChannelOutboundHandler 的基本实现。通过扩展抽象类 ChannelHandlerAdapter，它们获得了它们共同的超接口ChannelHandler 的方法。</p>
<p>ChannelHandlerAdapter 还提供了实用方法 isSharable()。如果其对应的实现被标注为 Sharable，那么这个方法将返回 true，表示它可以被添加到多个 ChannelPipeline中。</p>
<p>在 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 中所提供的方法体调用了其相关联的 ChannelHandlerContext 上的等效方法，从而将事件转发到了 ChannelPipeline 中的下一个 ChannelHandler 中。</p>
<h4 id="2-ChannelPipeline接口"><a href="#2-ChannelPipeline接口" class="headerlink" title="2. ChannelPipeline接口"></a>2. ChannelPipeline接口</h4><p><strong>ChannleHandlerContext:</strong>  ChannelHandlerContext使得ChannelHandler能够和它的ChannelPipeline以及其他的ChannelHandler交互。ChannelHandler可以通知其 所属的ChannelPipeline中的下一个ChannelHandler，甚至可以动态修改它所属的ChannelPipeline。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205191812446.png" alt="image-20201205191812446"></p>
<p><strong>ChannelPipeline的过滤筛选</strong></p>
<p>在 ChannelPipeline 传播事件时，它会测试 ChannelPipeline 中的下一个 ChannelHandler 的类型是否和事件的运动方向相匹配。如果不匹配，ChannelPipeline 将跳过该ChannelHandler 并前进到下一个，直到它找到和该事件所期望的方向相匹配的为止。</p>
<h5 id="2-1-修改ChannelPipeline"><a href="#2-1-修改ChannelPipeline" class="headerlink" title="2.1 修改ChannelPipeline"></a>2.1 修改ChannelPipeline</h5><p>​                                                    ChannelHandler的用于修改ChannelPipeline的方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>addFirst,addLast,addBefore,addAfter</td>
<td>将一个 ChannelHandler 添加到 ChannelPipeline 中</td>
</tr>
<tr>
<td>remove</td>
<td>将一个 ChannelHandler 从 ChannelPipeline 中移除</td>
</tr>
<tr>
<td>replace</td>
<td>将 ChannelPipeline中的一个 ChannelHandler 替换为另一个 ChannelHandler</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205195916893.png" alt="image-20201205195916893"></p>
<p><strong>ChannelHandler 的执行和阻塞</strong>: 通常 ChannelPipeline 中的每一个 ChannelHandler 都是通过它的 EventLoop（I/O 线程）来处理传递给它的事件的。所以至关重要的是不要阻塞这个线程，因为这会对整体的 I/O 处理产生负面的影响。可以使用netty提供的 <code>DefaultEventExecutorGroup</code>进行处理。</p>
<h5 id="2-2-触发事件"><a href="#2-2-触发事件" class="headerlink" title="2.2 触发事件"></a>2.2 触发事件</h5><p><strong>ChannelPipeline的入站操作</strong></p>
<h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205202618498.png" alt="image-20201205202618498"></h6><p>ChannelPipeline的出站操作</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205202826258.png" alt="image-20201205202826258"></p>
<ul>
<li>ChannelPipeline保存了Channel相关联的ChannelHandler;</li>
<li>ChannelPipeline可以根据需要，通过添加或删除ChannelHandler来动态地修改；</li>
<li>ChannelPipeline有着丰富的API可以被调用，以响应入站和出站事件</li>
</ul>
<h4 id="3-ChannelHandlerContext接口"><a href="#3-ChannelHandlerContext接口" class="headerlink" title="3. ChannelHandlerContext接口"></a>3. ChannelHandlerContext接口</h4><p>ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandlerContext。ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。</p>
<p>相同方法的调用：</p>
<p>Channel和ChannelPipeline: 会沿着整个ChannelPipeline传播</p>
<p>ChannelHandlerContext: 从当前所关联的 ChannelHandler 开始，并且只会传播给位于该ChannelPipeline 中的下一个能够处理该事件的ChannelHandler</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205204230623.png" alt="image-20201205204230623"></p>
<ul>
<li>ChannelHandlerContext和ChannelHandler之间的关联是不可变的，所以缓存对它的引用的安全的</li>
<li>相对于其他类的同名方法，ChannelHandlerContext的方法将产生更短的事件流，应该尽可能地利用这个特性来获得最大的性能</li>
</ul>
<h5 id="3-1-使用ChannelHandlerContext"><a href="#3-1-使用ChannelHandlerContext" class="headerlink" title="3.1 使用ChannelHandlerContext"></a>3.1 使用ChannelHandlerContext</h5><p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205211537126.png" alt="image-20201205211537126"></p>
<p><strong>从ChannelHandlerContext访问Channel</strong></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205214844754.png" alt="image-20201205214844754"></p>
<p><strong>从ChannelHandlerContext访问ChannelPipeline</strong></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205215008778.png" alt="image-20201205215008778"></p>
<p>事件流是一样的，从ChannelHandler的级别上看，事件从一个 ChannelHandler到下一个ChannelHandler 的移动是由 ChannelHandlerContext 上的调用完成的</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205215228539.png" alt="image-20201205215228539"></p>
<p>为什么会想要从 ChannelPipeline 中的某个特定点开始传播事件呢？</p>
<ul>
<li>为了减少将事件传经对它不感兴趣的 ChannelHandler 所带来的开销</li>
<li>为了避免将事件传经那些可能会对它感兴趣的 ChannelHandler</li>
</ul>
<p>想从指定ChannelHandler传播事件，获取该ChannelHandler的前一个Channelhandler关联的ChannelHandlerContext，调用write()方法将事件传播给该ChannelHandler</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205215928052.png" alt="image-20201205215928052"></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205215842844.png" alt="image-20201205215842844"></p>
<h4 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h4><h5 id="1-处理入站异常"><a href="#1-处理入站异常" class="headerlink" title="1. 处理入站异常"></a>1. 处理入站异常</h5><p>如果在处理入站事件的过程中有异常被抛出，那么它将从它在 ChannelInboundHandler里被触发的那一点开始流经 ChannelPipeline。重写exceptionCaught()方法，捕获异常即可。如果你不实现任何处理入站异常的逻辑（或者没有消费该异常），那么异常会被传到pipeline末端，Netty将会记录该异常没有被处理的事实。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205221959288.png" alt="image-20201205221959288"></p>
<ul>
<li>ChannelHandler.exceptionCaught()的默认实现是简单地将当前异常转发给ChannelPipeline 中的下一个 ChannelHandler</li>
<li>如果异常到达了 ChannelPipeline 的尾端，它将会被记录为未被处理</li>
<li>要想定义自定义的处理逻辑，你需要重写 exceptionCaught()方法。然后你需要决定是否需要将该异常传播</li>
</ul>
<h5 id="2-处理出站异常"><a href="#2-处理出站异常" class="headerlink" title="2. 处理出站异常"></a>2. 处理出站异常</h5><p>用于处理出站操作中的正常完成以及异常的选项，都基于以下的通知机制。</p>
<ul>
<li>每个出站操作都将返回一个 ChannelFuture。注册到 ChannelFuture 的 ChannelFutureListener 将在操作完成时被通知该操作是成功了还是出错了。</li>
<li>几乎所有的 ChannelOutboundHandler 上的方法都会传入一个 ChannelPromise的实例。作为 ChannelFuture 的子类，ChannelPromise 也可以被分配用于异步通知的监听器。</li>
</ul>
<p>第一种方式：<strong>添加ChannelFutureListener到ChannelFuture</strong></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205230338069.png" alt="image-20201205230338069"></p>
<p>第二种方式：<strong>将 ChannelFutureListener 添加到即将作为参数传递给 ChannelOutboundHandler 的方法的ChannelPromise</strong></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20201205230101135.png" alt="image-20201205230101135"></p>
<p>在调用出站操作时添加 ChannelFutureListener 更合适（第一种方式），而对于一般的异常处理，自定义的ChannelOutboundHandler 实现的方式更加的简单（第二种方式）。</p>
<h3 id="Chapter7-EventLoop和线程模型"><a href="#Chapter7-EventLoop和线程模型" class="headerlink" title="Chapter7-EventLoop和线程模型"></a>Chapter7-EventLoop和线程模型</h3><h4 id="1-Executor线程模型"><a href="#1-Executor线程模型" class="headerlink" title="1.Executor线程模型"></a>1.Executor线程模型</h4><ul>
<li>从池的空闲线程列表选择一个Thread，并且指派它去运行一个已经提交的任务（一个Runable实现）</li>
<li>当任务完成时，将该Thread返回列表，使其可被重用</li>
</ul>
<p>优点：池化和重用线程</p>
<p>缺点：不能消除上下文切换带来的开销，并且随线程数量增加而变得明显</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220104203014131.png" alt="image-20220104203014131"></p>
<h4 id="2-EventLoop接口"><a href="#2-EventLoop接口" class="headerlink" title="2.EventLoop接口"></a>2.EventLoop接口</h4><p>Netty 的 EventLoop 是协同设计的一部分，它采用了两个基本的 API：并发和网络编程</p>
<p>一个EventLoop由一个永不改变的Thread驱动，同时任务（Runnable或者Callable）可以直接提交给EventLoop实现，以立即执行或者调度执行。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220104203739603.png" alt="image-20220104203739603"></p>
<h4 id="3-FIFO"><a href="#3-FIFO" class="headerlink" title="3.FIFO"></a>3.FIFO</h4><p>FIrst In First Out，事件和任务都是以先进先出（FIFO）的顺序执行，保证字节内容时按正确的顺序被处理。</p>
<p>在Netty4中，所有的I/O操作和事件都由已经分配给了EventLoop的那个Thread进行处理。</p>
<h4 id="4-任务调度"><a href="#4-任务调度" class="headerlink" title="4.任务调度"></a>4.任务调度</h4><p>调度一个任务以便稍后（延迟）执行或者周期性地执行</p>
<h5 id="4-1JDK的API"><a href="#4-1JDK的API" class="headerlink" title="4.1JDK的API"></a>4.1JDK的API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//10s后执行任务，一旦调度任务完成，就会关闭ScheduledExecutorService以释放资源</span></span><br><span class="line">        ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        executor.schedule(() -&gt; System.out.println(<span class="string">&quot;10 seconds later&quot;</span>), <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2EventLoop"><a href="#4-2EventLoop" class="headerlink" title="4.2EventLoop"></a>4.2EventLoop</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(group)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                            <span class="comment">//do nothing, just test</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture future = b.bind().sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;NettyServer start...&quot;</span>);</span><br><span class="line">            Channel ch = future.channel();</span><br><span class="line">            <span class="comment">//使用 EventLoop 调度任务, 10s后执行任务，只执行一次</span></span><br><span class="line"><span class="comment">//            ch.eventLoop().schedule(() -&gt; System.out.println(&quot;10 seconds later&quot;), 10, TimeUnit.SECONDS);</span></span><br><span class="line">            <span class="comment">//使用 EventLoop 调度任务, 10s后任务， 每隔10s后执行任务</span></span><br><span class="line">            ch.eventLoop().scheduleAtFixedRate(() -&gt; System.out.println(<span class="string">&quot;10 seconds later&quot;</span>), <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-实现细节"><a href="#5-实现细节" class="headerlink" title="5.实现细节"></a>5.实现细节</h4><h5 id="5-1线程管理"><a href="#5-1线程管理" class="headerlink" title="5.1线程管理"></a>5.1线程管理</h5><p>Netty线程模型的卓越性能取决于对于当前执行的Thread身份的确认，即确定它是否时分配给当前Channel和EventLoop的那一个线程。</p>
<p>如果是，则将所提交的代码直接执行。否则，EventLoop调度该任务以便稍后执行，并将它放入内部队列。</p>
<p>注意，不要将长时间运行的的任务放入执行队列，会阻塞IO线程，建议使用EventExecutor。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220104205902131.png" alt="image-20220104205902131"></p>
<h5 id="5-2EventLoop线程分配"><a href="#5-2EventLoop线程分配" class="headerlink" title="5.2EventLoop线程分配"></a>5.2EventLoop线程分配</h5><p>相比于传统的IO 传输（一对一，即一个线程对应一个通道），EventLoop的异步传输（一对多，即一个线程对应多个通道）可以使用少量的线程来支撑大量的Channel，避免过多线程上文切换带来的额外开销。</p>
<p>EventLoopGroup为每个新建的Channel分配一个EventLoop（管理多个Channel），使用事件循环（round-robin）方式进行分配以获取一个均衡的分布。</p>
<p>一旦一个Channel被分配给了一个EventLoop，那么它整个生命周期都是用这个EventLoop及其绑定的线程，避免了线程安全和线程同步问题（有且仅有当前这一个线程）。</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220104211050089.png" alt="image-20220104211050089"></p>
<h3 id="Chapter8-引导"><a href="#Chapter8-引导" class="headerlink" title="Chapter8-引导"></a>Chapter8-引导</h3><p>引导，即将ChannelPipeline、ChannelHandler、EventLoop组织配置，成为一个可以实际运行的应用</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220110202427957.png" alt="image-20220110202427957"></p>
<h4 id="8-1Bootstrap-引导客户端"><a href="#8-1Bootstrap-引导客户端" class="headerlink" title="8.1Bootstrap-引导客户端"></a>8.1Bootstrap-引导客户端</h4><p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220110203343888.png" alt="image-20220110203343888"></p>
<p><img src="img/image-20220110203103764.png" alt="image-20220110203103764"></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220110203115724.png" alt="image-20220110203115724"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;ByteBuf&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Reveive data from ServerA: &quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ctx.channel().eventLoop().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">                            ByteBuf data = Unpooled.copiedBuffer(<span class="string">&quot;Hello, I am ClientA&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">                            ctx.writeAndFlush(data);</span><br><span class="line">                        &#125;, <span class="number">0</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        ChannelFuture future = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        future.addListener((ChannelFutureListener) channelFuture -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (channelFuture.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Connect success&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Connect failed&quot;</span>);</span><br><span class="line">                channelFuture.cause().printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2ServerBootstrap-引导服务器"><a href="#8-2ServerBootstrap-引导服务器" class="headerlink" title="8.2ServerBootstrap-引导服务器"></a>8.2ServerBootstrap-引导服务器</h4><p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220110203638620.png" alt="image-20220110203638620"></p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220110203746456.png" alt="image-20220110203746456"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//group、channel、childHandler三者是必须的，不然会导致IllegalStateException</span></span><br><span class="line">        serverBootstrap.group(bossGroup, workGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * ChannelInitializer是ChannelInboundHandlerAdapter子类，可以添加多个处理器</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">//可以继续添加处理器，解码器，编码器等等</span></span><br><span class="line">                        channel.pipeline().addLast(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        ChannelFuture future = serverBootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        future.addListener((ChannelFutureListener) channelFuture -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (channelFuture.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Server bound&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Bind attempt failed&quot;</span>);</span><br><span class="line">                channelFuture.cause().printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器端处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ChannelFuture connectFuture;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="comment">//使用与分配给已被接受的子Channel相同的EventLoop</span></span><br><span class="line">            <span class="comment">//ServerA与ServerB通信，ServerA将ServerB的消息转发给ClientA</span></span><br><span class="line">            bootstrap.group(ctx.channel().eventLoop())</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;ByteBuf&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;Reveived data from ServerB：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">                            ByteBuf msg = Unpooled.copiedBuffer(<span class="string">&quot;Hello, I am ServerA&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">                            channelHandlerContext.writeAndFlush(msg);</span><br><span class="line">                            <span class="comment">//将ServerB的消息转发给ClientA</span></span><br><span class="line"><span class="comment">//                            System.out.println(&quot;before:&quot; + byteBuf.refCnt());</span></span><br><span class="line">                            <span class="comment">//SimpleChannelInboundHandler 它会自动进行一次释放(即引用计数减1),如果不想创建新的数据, 则可以直接在原对象里调用 byteBuf.retain() 进行引用计数加1</span></span><br><span class="line">                            byteBuf.retain();</span><br><span class="line">                            ctx.writeAndFlush(byteBuf);</span><br><span class="line"><span class="comment">//                            System.out.println(&quot;after:&quot; + byteBuf.refCnt());</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            connectFuture = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1234</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (connectFuture.isDone()) &#123;</span><br><span class="line">                <span class="comment">//当连接完成后，执行一些数据操作（如代理）</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Reveived data from ClientA：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">                ByteBuf data = Unpooled.copiedBuffer(<span class="string">&quot;Hello, ClientA&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">                ctx.writeAndFlush(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        serverBootstrap.group(bossGroup, workGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;ByteBuf&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Reveive data from ServerA: &quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ctx.channel().eventLoop().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">                            ByteBuf data = Unpooled.copiedBuffer(<span class="string">&quot;Hello, I am ServerB&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">                            ctx.writeAndFlush(data);</span><br><span class="line">                        &#125;, <span class="number">0</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        ChannelFuture future = serverBootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));</span><br><span class="line">        future.addListener((ChannelFutureListener) channelFuture -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (channelFuture.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Server bound&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Bind attempt failed&quot;</span>);</span><br><span class="line">                channelFuture.cause().printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-3ChannelOption-amp-Attr"><a href="#8-3ChannelOption-amp-Attr" class="headerlink" title="8.3ChannelOption&amp;Attr"></a>8.3ChannelOption&amp;Attr</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AttributeKey&lt;Integer&gt; id = AttributeKey.newInstance(<span class="string">&quot;ID&quot;</span>);</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;ByteBuf&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Reviive data from ServerB: &quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Integer idValue = ctx.channel().attr(id).get();</span><br><span class="line">                        System.out.println(<span class="string">&quot;idValue: &quot;</span> + idValue);</span><br><span class="line">                        <span class="comment">//do something with the idValue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        ChannelFuture future = bootstrap.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">                .attr(id, <span class="number">123456</span>)</span><br><span class="line">                .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1234</span>));</span><br><span class="line">        future.syncUninterruptibly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-4引导DatagramChannel"><a href="#8-4引导DatagramChannel" class="headerlink" title="8.4引导DatagramChannel"></a>8.4引导DatagramChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> OioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(OioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;ByteBuf&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Receive data: &quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">//调用bind()方法，因为该协议是无连接的</span></span><br><span class="line">        ChannelFuture future = bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>));</span><br><span class="line">        future.addListener((ChannelFutureListener) channelFuture -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (channelFuture.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Channel bind&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;bind attempt failed&quot;</span>);</span><br><span class="line">                channelFuture.cause().printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Chapter9-单元测试"><a href="#Chapter9-单元测试" class="headerlink" title="Chapter9-单元测试"></a>Chapter9-单元测试</h3><h4 id="9-1EmbeddedChannel"><a href="#9-1EmbeddedChannel" class="headerlink" title="9.1EmbeddedChannel"></a>9.1EmbeddedChannel</h4><p>Netty提供了一种特殊的Channel实现-EmbeddedChannel，专门用来对ChannelHandler进行单元测试</p>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220111235435043.png" alt="image-20220111235435043"></p>
<ul>
<li>入站数据由 <strong>ChannelInboundHandler</strong> 处理，代表从远程节点读取的数据，使用Inbound()方法</li>
<li>出站数据由 <strong>ChannelOutboundHandler</strong> 处理，代表将要写到远程节点的数据，使用Outbound()方法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Qianfugen/blog-img/main/image-20220111235804630.png" alt="image-20220111235804630"></p>
<h4 id="9-2测试入站消息"><a href="#9-2测试入站消息" class="headerlink" title="9.2测试入站消息"></a>9.2测试入站消息</h4><p>待测试的入站处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedLenghtFrameDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> frameLength;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedLenghtFrameDecoder</span><span class="params">(<span class="keyword">int</span> frameLength)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (frameLength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;frameLength must be a positive integer: &quot;</span> + frameLength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frameLength = frameLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (in.readableBytes() &gt;= frameLength) &#123;</span><br><span class="line">            ByteBuf byteBuf = in.readBytes(frameLength);</span><br><span class="line">            out.add(byteBuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedLenghtFrameDecoderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFramesDecoded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ByteBuf buf = Unpooled.buffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            buf.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line">        ByteBuf input = buf.duplicate();</span><br><span class="line">        EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> FixedLenghtFrameDecoder(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//write bytes</span></span><br><span class="line">        assertTrue(channel.writeInbound(input.retain()));</span><br><span class="line">        assertTrue(channel.finish());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//read bytes</span></span><br><span class="line">        ByteBuf read = (ByteBuf) channel.readInbound();</span><br><span class="line">        assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">        read.release();</span><br><span class="line"></span><br><span class="line">        read = (ByteBuf) channel.readInbound();</span><br><span class="line">        assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">        read.release();</span><br><span class="line"></span><br><span class="line">        read = (ByteBuf) channel.readInbound();</span><br><span class="line">        assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">        read.release();</span><br><span class="line"></span><br><span class="line">        assertNull(channel.readInbound());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFramesDecoded2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ByteBuf buf = Unpooled.buffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            buf.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line">        ByteBuf input = buf.duplicate();</span><br><span class="line">        EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> FixedLenghtFrameDecoder(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//write bytes</span></span><br><span class="line">        assertFalse(channel.writeInbound(input.readBytes(<span class="number">2</span>)));</span><br><span class="line">        assertTrue(channel.writeInbound(input.readBytes(<span class="number">7</span>)));</span><br><span class="line">        assertTrue(channel.finish());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//read bytes</span></span><br><span class="line">        ByteBuf read = (ByteBuf) channel.readInbound();</span><br><span class="line">        assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">        read.release();</span><br><span class="line"></span><br><span class="line">        read = (ByteBuf) channel.readInbound();</span><br><span class="line">        assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">        read.release();</span><br><span class="line"></span><br><span class="line">        read = (ByteBuf) channel.readInbound();</span><br><span class="line">        assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">        System.out.println(ByteBufUtil.hexDump(read));</span><br><span class="line">        read.release();</span><br><span class="line"></span><br><span class="line">        assertNull(channel.readInbound());</span><br><span class="line">        buf.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3测试出站消息"><a href="#9-3测试出站消息" class="headerlink" title="9.3测试出站消息"></a>9.3测试出站消息</h4><p>待测试的出站处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsIntegerEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = Math.abs(in.readInt());</span><br><span class="line">            out.add(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsIntegerEncoderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEncoded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ByteBuf buf = Unpooled.buffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buf.writeInt(i * -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> AbsIntegerEncoder());</span><br><span class="line">        assertTrue(channel.writeOutbound(buf));</span><br><span class="line">        assertTrue(channel.finish());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//read bytes</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            assertEquals(i, channel.readOutbound());</span><br><span class="line">        &#125;</span><br><span class="line">        assertNull(channel.readOutbound());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4测试异常处理"><a href="#9-4测试异常处理" class="headerlink" title="9.4测试异常处理"></a>9.4测试异常处理</h4><p>待测试的异常处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameChunkDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxFrameSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameChunkDecoder</span><span class="params">(<span class="keyword">int</span> maxFrameSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxFrameSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxFrameSize must &gt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.maxFrameSize = maxFrameSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> readableBytes = in.readableBytes();</span><br><span class="line">        <span class="keyword">if</span> (readableBytes &gt; maxFrameSize) &#123;</span><br><span class="line">            <span class="comment">//如果帧超过限制，就丢弃</span></span><br><span class="line">            in.clear();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TooLongFrameException();</span><br><span class="line">        &#125;</span><br><span class="line">        ByteBuf byteBuf = in.readBytes(readableBytes);</span><br><span class="line">        out.add(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameChunkDecoderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFrameDecoded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ByteBuf buf = Unpooled.buffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            buf.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line">        ByteBuf input = buf.duplicate();</span><br><span class="line">        EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> FrameChunkDecoder(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//write bytes</span></span><br><span class="line">        assertTrue(channel.writeInbound(input.readBytes(<span class="number">2</span>)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            assertTrue(channel.writeInbound(input.readBytes(<span class="number">4</span>)));</span><br><span class="line">            Assert.fail();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TooLongFrameException e) &#123;</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">        assertTrue(channel.writeInbound(input.readBytes(<span class="number">3</span>)));</span><br><span class="line">        assertTrue(channel.finish());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//read Bytes</span></span><br><span class="line">        ByteBuf read = (ByteBuf) channel.readInbound();</span><br><span class="line">        assertEquals(buf.readSlice(<span class="number">2</span>), read);</span><br><span class="line"></span><br><span class="line">        read = (ByteBuf) channel.readInbound();</span><br><span class="line">        assertEquals(buf.skipBytes(<span class="number">4</span>).readSlice(<span class="number">3</span>), read);</span><br><span class="line">        read.release();</span><br><span class="line">        buf.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Chapter10-编解码器"><a href="#Chapter10-编解码器" class="headerlink" title="Chapter10-编解码器"></a>Chapter10-编解码器</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>编码器是将消息转换为适合于传输的格式（最有可能的就是字节流），</p>
<p>解码器则是将网络字节流转换回应用程序的消息格式。</p>
<h4 id="2-解码器"><a href="#2-解码器" class="headerlink" title="2.解码器"></a>2.解码器</h4><ul>
<li>将字节解码为消息：ByteToMessageDecoder 和 ReplayingDecoder</li>
<li>将一种消息类型解码为另一种：MessageToMessageDecoder</li>
<li>都需要重写**decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)**方法；</li>
</ul>
<h5 id="2-1ByteToMessageDecoder"><a href="#2-1ByteToMessageDecoder" class="headerlink" title="2.1ByteToMessageDecoder"></a>2.1ByteToMessageDecoder</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">        System.out.println(ByteBufUtil.hexDump(in));</span><br><span class="line">        <span class="comment">//在调用 readInt()方法前不得不验证所输入的 ByteBuf 是否具有足够的数据有点繁琐</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            out.add(in.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">        out.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2ReplayingDecoder"><a href="#2-2ReplayingDecoder" class="headerlink" title="2.2ReplayingDecoder"></a>2.2ReplayingDecoder</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToInteger2Decoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">        ByteBufUtil.hexDump(in);</span><br><span class="line">        <span class="comment">//字节数不够，报错：java.lang.NegativeArraySizeException</span></span><br><span class="line">        out.add(in.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3MessageToMessageDecoder"><a href="#2-3MessageToMessageDecoder" class="headerlink" title="2.3MessageToMessageDecoder"></a>2.3MessageToMessageDecoder</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, Integer in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数字&quot;</span> + in + <span class="string">&quot;转成字符串&quot;</span>);</span><br><span class="line">        out.add(String.valueOf(in));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4其他"><a href="#2-4其他" class="headerlink" title="2.4其他"></a>2.4其他</h5><p>还有netty自带的<strong>LineBasedFrameDecoder</strong>、<strong>HttpObjectAggregator</strong>等；</p>
<p><strong>TooLongFrameException 类</strong></p>
<p>由于 Netty 是一个异步框架，所以需要在字节可以解码之前在内存中缓冲它们。因此，不能 让解码器缓冲大量的数据以至于耗尽可用的内存。为了解除这个常见的顾虑，Netty 提供了 TooLongFrameException 类，其将由解码器在帧超出指定的大小限制时抛出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeByteToMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FRAME_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = in.readableBytes();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; MAX_FRAME_SIZE) &#123;</span><br><span class="line">            in.skipBytes(size);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TooLongFrameException(<span class="string">&quot;Frame too big&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.add(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-编码器"><a href="#3-编码器" class="headerlink" title="3.编码器"></a>3.编码器</h4><ul>
<li>将消息编码为字节</li>
<li>将消息编码为消息</li>
<li>都需要重写**encode(ChannelHandlerContext ctx, Short msg, ByteBuf out)**方法</li>
</ul>
<h5 id="3-1MessageToByteEncoder"><a href="#3-1MessageToByteEncoder" class="headerlink" title="3.1MessageToByteEncoder"></a>3.1MessageToByteEncoder</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Short</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Short msg, ByteBuf out)</span> </span>&#123;</span><br><span class="line">        out.writeShort(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2MessageToMessageEncoder"><a href="#3-2MessageToMessageEncoder" class="headerlink" title="3.2MessageToMessageEncoder"></a>3.2MessageToMessageEncoder</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">        out.add(String.valueOf(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3其他"><a href="#3-3其他" class="headerlink" title="3.3其他"></a>3.3其他</h5><p>还有netty自带的<strong>ProtobufEncoder</strong>等，处理了Google 的 Protocol Buffers 规范所定义的数据格式</p>
<h4 id="4-编解码器"><a href="#4-编解码器" class="headerlink" title="4.编解码器"></a>4.编解码器</h4><p>同时实现了 ChannelInboundHandler 和 ChannelOutboundHandler 接口</p>
<h5 id="4-1抽象类-ByteToMessageCodec"><a href="#4-1抽象类-ByteToMessageCodec" class="headerlink" title="4.1抽象类 ByteToMessageCodec"></a>4.1抽象类 ByteToMessageCodec</h5><p>任何的请求/响应协议都可以作为使用ByteToMessageCodec的理想选择。例如，在某个 SMTP的实现中，编解码器将读取传入字节，并将它们解码为一个自定义的消息类型，如 SmtpRequest, 而在接收端，当一个响应被创建时，将会产生一个SmtpResponse，其将被 编码回字节以便进行传输</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SMTPClientFutureListener&lt;FutureResult&lt;SMTPResponse&gt;&gt; getListener(SMTPClientSession session, SMTPRequest request) <span class="keyword">throws</span> SMTPException &#123;</span><br><span class="line"></span><br><span class="line">      String cmd = request.getCommand().toUpperCase(Locale.UK);</span><br><span class="line">      String arg = request.getArgument();</span><br><span class="line">      <span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">          arg = arg.toUpperCase(Locale.UK);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (SMTPRequest.EHLO_COMMAND.equals(cmd)) &#123;</span><br><span class="line">          <span class="keyword">return</span> EhloResponseListener.INSTANCE;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SMTPRequest.HELO_COMMAND.equals(cmd)) &#123;</span><br><span class="line">          <span class="keyword">return</span> HeloResponseListener.INSTANCE;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SMTPRequest.MAIL_COMMAND.equals(cmd)) &#123;</span><br><span class="line">          <span class="keyword">return</span> MailResponseListener.INSTANCE;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SMTPRequest.RCPT_COMMAND.equals(cmd)) &#123;</span><br><span class="line">          <span class="keyword">return</span> RcptResponseListener.INSTANCE;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SMTPRequest.DATA_COMMAND.equals(cmd)) &#123;</span><br><span class="line">          <span class="keyword">return</span> DataResponseListener.INSTANCE;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SMTPRequest.STARTTLS_COMMAND.equals(cmd)) &#123;</span><br><span class="line">          <span class="keyword">return</span> StartTlsResponseListener.INSTANCE;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SMTPRequest.AUTH_COMMAND.equals(cmd) &amp;&amp; arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (arg.equals(SMTPRequest.AUTH_PLAIN_ARGUMENT)) &#123;</span><br><span class="line">              <span class="keyword">return</span> AuthPlainResponseListener.INSTANCE;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg.equals(SMTPRequest.AUTH_LOGIN_ARGUMENT)) &#123;</span><br><span class="line">              <span class="keyword">return</span> AuthLoginResponseListener.INSTANCE;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SMTPRequest.QUIT_COMMAND.equals(cmd)) &#123;</span><br><span class="line">          <span class="keyword">return</span> QuitResponseListener.INSTANCE;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SMTPException(<span class="string">&quot;No valid callback found for request &quot;</span> + request);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2抽象类-MessageToMessageCodec"><a href="#4-2抽象类-MessageToMessageCodec" class="headerlink" title="4.2抽象类 MessageToMessageCodec"></a>4.2抽象类 MessageToMessageCodec</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConvertHandler</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">WebSocketFrame</span>, <span class="title">WebSocketConvertHandler</span>.<span class="title">MyWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, MyWebSocketFrame msg, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">        ByteBuf payload = msg.getData().duplicate().retain();</span><br><span class="line">        <span class="keyword">switch</span> (msg.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINARY:</span><br><span class="line">                out.add(<span class="keyword">new</span> BinaryWebSocketFrame(payload));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSE:</span><br><span class="line">                out.add(<span class="keyword">new</span> CloseWebSocketFrame(<span class="keyword">true</span>, <span class="number">0</span>, payload));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PING:</span><br><span class="line">                out.add(<span class="keyword">new</span> PingWebSocketFrame(payload));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PONG:</span><br><span class="line">                out.add(<span class="keyword">new</span> PongWebSocketFrame(payload));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TEXT:</span><br><span class="line">                out.add(<span class="keyword">new</span> TextWebSocketFrame(payload));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CONTINUATION:</span><br><span class="line">                out.add(<span class="keyword">new</span> ContinuationWebSocketFrame(payload));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unsupported websocket msg: &quot;</span> + msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, WebSocketFrame msg, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">        ByteBuf payload = msg.content().duplicate().retain();</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> BinaryWebSocketFrame) &#123;</span><br><span class="line">            out.add(<span class="keyword">new</span> MyWebSocketFrame(MyWebSocketFrame.FrameType.BINARY, payload));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> CloseWebSocketFrame) &#123;</span><br><span class="line">            out.add(<span class="keyword">new</span> MyWebSocketFrame(MyWebSocketFrame.FrameType.CLOSE, payload));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> PingWebSocketFrame) &#123;</span><br><span class="line">            out.add(<span class="keyword">new</span> MyWebSocketFrame(MyWebSocketFrame.FrameType.PING, payload));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> PongWebSocketFrame) &#123;</span><br><span class="line">            out.add(<span class="keyword">new</span> MyWebSocketFrame(MyWebSocketFrame.FrameType.PING, payload));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> TextWebSocketFrame) &#123;</span><br><span class="line">            out.add(<span class="keyword">new</span> MyWebSocketFrame(MyWebSocketFrame.FrameType.TEXT, payload));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ContinuationWebSocketFrame) &#123;</span><br><span class="line">            out.add(<span class="keyword">new</span> MyWebSocketFrame(MyWebSocketFrame.FrameType.CONTINUATION, payload));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unsupported websocket msg: &quot;</span> + msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebSocketFrame</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">FrameType</span> </span>&#123;</span><br><span class="line">            BINARY,</span><br><span class="line">            CLOSE,</span><br><span class="line">            PING,</span><br><span class="line">            PONG,</span><br><span class="line">            TEXT,</span><br><span class="line">            CONTINUATION</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> FrameType type;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ByteBuf data;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyWebSocketFrame</span><span class="params">(FrameType type, ByteBuf data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.type = type;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FrameType <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3CombinedChannelDuplexHandler-类"><a href="#4-3CombinedChannelDuplexHandler-类" class="headerlink" title="4.3CombinedChannelDuplexHandler 类"></a>4.3CombinedChannelDuplexHandler 类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombineByteCharCodec</span> <span class="keyword">extends</span> <span class="title">CombinedChannelDuplexHandler</span>&lt;<span class="title">CombineByteCharCodec</span>.<span class="title">ByteToCharDecoder</span>, <span class="title">CombineByteCharCodec</span>.<span class="title">CharToByteEncoder</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CombineByteCharCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> ByteToCharDecoder(), <span class="keyword">new</span> CharToByteEncoder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToCharDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (in.readableBytes() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                out.add(in.readChar());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Character</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Character msg, ByteBuf out)</span> </span>&#123;</span><br><span class="line">            out.writeChar(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/netty/" rel="tag"># netty</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/12/25/hello-world/" rel="prev" title="Hello World">
                  <i class="fa fa-chevron-left"></i> Hello World
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/01/MySQL%E7%AC%94%E8%AE%B0/" rel="next" title="MySQL笔记">
                  MySQL笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qianfg</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
